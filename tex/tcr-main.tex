\documentclass[10pt,a4paper,ngerman,oneside,
%twocolumn
]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\setlength{\columnseprule}{0.25pt}
\linespread{1.180}
\usepackage{fancyhdr}
%\usepackage[landscape,left=.5cm,right=.5cm,top=2.1cm,bottom=.5cm]{geometry}
\usepackage[left=1cm,right=.75cm,top=2.1cm,bottom=.5cm]{geometry}
\pagestyle{fancy}
\fancyhf{}
\fancyhead[RE,RO]{ACM ICPC Reference, page \bfseries\thepage}
\fancyhead[LE,LO]{Universität zu Lübeck}

\usepackage[safe,warn]{textcomp}
\usepackage{tgtermes}
\usepackage[scaled]{berasans}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{algorithm}
\usepackage{algorithmic}


\renewcommand*\ttdefault{txtt}
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\ggT}{\ensuremath{\operatorname{ggT}}}


\usepackage{listings}
\lstset{frame=left}
\usepackage{multicol} 

\title{Team Contest Reference}
\author{Universität zu Lübeck}
\begin{document}
\lstset{basicstyle=\ttfamily\footnotesize,numbers=left,numberstyle=\tiny,tabsize=2,numbersep=5pt}
\maketitle
\thispagestyle{fancy}
\begin{multicols}{2}
\tableofcontents
\end{multicols}
\newpage

\section{Mathematische Algorithmen}
\subsection{Primzahlen}
Für Primzahlen gilt immer (aber nicht nur für Primzahlen)
\[a^p\equiv a\mod p \quad\text{ bzw. }\quad a^{p-1}\equiv 1 \mod p.\]
\subsubsection{Sieb des Eratosthenes}
\lstinputlisting[language=Java]{eratosthenes.java}
\subsubsection{Primzahlentest}
\lstinputlisting[language=Java]{isprim.java}
\subsection{Binomial Koeffizient}
\lstinputlisting[language=Java]{binomial.java}
\subsection{Eulersche $\varphi$-Funktion}
$\varphi(n\in\N):=|\{a\in\N |1\leq a \leq n \wedge \ggT (a,n)=1\}|$\\
$\varphi(n\cdot m)=\varphi(n)\cdot\varphi(m)$
\lstinputlisting[language=C++]{phi.cpp}
\section{Mathematisch Formeln und Gesetze}
\subsection{Catalan}
$C_n = \frac1{n+1}\binom{2n}{n}=\prod_{k=2}^n (n+k)/k$\\
$C_{n+1} = \frac{4n+2}{n+2}C_n=\sum_{k=0}^{n}C_kC_{n-k}$
\subsection{kgV und ggT}
$ggT(n,m)\cdot kgV(m,n)=|m\cdot n|$
\subsection{modulare Exponentiation}
$b^e \equiv c (\mod) m$\\
$b^e = b^{\left( \sum_{i=0}^{n-1} a_i 2^i \right)} = \prod_{i=0}^{n-1} \left( b^{2^i} \right) ^ {a_i}$
\begin{lstlisting}[language=pascal]
function modular_pow(base, exponent, modulus)
    result := 1
    while exponent > 0
        if (exponent mod 2 == 1):
           result := (result * base) mod modulus
        exponent := exponent >> 1
        base = (base * base) mod modulus
    return result
\end{lstlisting}
\subsection{Kreuzprodukt}
$\vec{a}\times\vec{b}
  =
  \begin{pmatrix}a_1 \\ a_2 \\ a_3\end{pmatrix}
  \times
  \begin{pmatrix}b_1 \\ b_2 \\ b_3 \end{pmatrix}
  =
  \begin{pmatrix}
    a_2b_3 - a_3b_2 \\
    a_3b_1 - a_1b_3 \\
    a_1b_2 - a_2b_1
  \end{pmatrix}$
\subsection{Orthogonale Projektion}
$r_0:$ Ortsvektor; $u:$ Richtungsvektor; $n:$ Normalenvektor\\
$P_g(\vec x) =  \vec r_0 + \frac{( \vec x - \vec r_0 ) \cdot \vec u}{\vec u \cdot \vec u} \, \vec u$\\
$P_g(\vec x) = \vec x - \frac{( \vec x - \vec r_0 ) \cdot \vec n}{\vec n \cdot \vec n} \, \vec n$(nur 2D bzw. 3D auf Ebene)\\
\subsection{Geradenschnittpunkt}
$g_1: ax+by=c;\,g_2: px+qx=r;\;\Rightarrow \vec{p}=\frac{1}{aq-bp}\begin{pmatrix}
x = cq-br\\y=ar-cp
\end{pmatrix}$\\
$
g_1: \vec{p}=\begin{pmatrix}r_x\\r_y\end{pmatrix}+ s \begin{pmatrix}s_x\\s_y\end{pmatrix}\;
g_2: \vec{p}=\begin{pmatrix}q_x\\q_y\end{pmatrix}+ t \begin{pmatrix}t_x\\t_y\end{pmatrix}\; w_x=(r_x-q_x),  w_y=(r_y-q_y)\\
\Rightarrow D=(s_xt_y-t_xs_y)\, D_s=(t_xw_y-t_yw_x)\,D_t=(s_yw_x-s_xw_y)\; s=D_s/D, t=D_t/D$
\subsection{Trigonometrie}
$\sin ( x \pm y ) = \sin x \; \cos y \pm \sin y \; \cos x </math><ref name="forster anal1"> Otto Forster ''Analysis 1 Differential- und Integralrechnung einer Veränderlichen'' vieweg 1983 Seite 87</ref>
\cos ( x \pm y ) = \cos x \; \cos y \mp \sin x \; \sin y </math><ref name="forster anal1" />

\tan ( x + y ) = \frac{ \tan x + \tan y }{ 1 - \tan x \; \tan y } = \frac{ \sin (x + y) }{ \cos (x + y) }</math>
\tan ( x - y ) = \frac{ \tan x - \tan y }{ 1 + \tan x \; \tan y } = \frac{ \sin (x - y) }{ \cos (x - y) }</math>

\cot \left( x+y\right) =\frac{\cot x\cot y-1}{\cot x+\cot y} = \frac{ \cos (x + y) }{ \sin (x + y) }</math>

\cot \left( x-y\right) =\frac{\cot x\cot y+1}{\cot y -\cot x} = \frac{ \cos (x - y) }{ \sin (x - y) }</math>

''x'' = ''y'' \\
y = \frac{\pi}{2}\\
\sin ( x + y ) \cdot \sin ( x - y ) = \cos^2 y - \cos^2 x  = \sin^2 x - \sin^2 y \\
\cos ( x + y ) \cdot \cos ( x - y ) = \cos^2 y - \sin^2 x  = \cos^2 y + \cos^2 x - 1= 1-\sin^2 x - \sin ^2 y$
\subsection{Dreicksfläche}
$F=\sqrt{s(s-a)(s-b)(s-c)};\,s=\frac{a+b+c}{2}$
\subsection{Kombinatorik}
\begin{tabular}{|c||c|c|}\hline
 & mit ZL & ohne ZL\\\hline\hline
Variationen & $n^k$ & $\frac{n!}{(n-k)!}$\\\hline
Kombinationen & $\binom{n}{k}=\binom{n}{n-k}=\frac{n!}{k!(n-k)!}$ & $\binom{n+k-1}{k}=\binom{n+k-1}{n-1}$\\\hline
\end{tabular}

\subsection{Modulare Arithmetik}
Bedeutung der größten gemeinsamen Teiler:
\[ d = \text{ggT}(a,b) = as+bt \]
Verwendung zu Berechnung des inversen Elements $b$ zu $a$ bezüglich einer Restklassengruppe $n$ ($a$ und $n$ müssen teilerfremd sein):
\[ ab\equiv 1 \mod n\quad\Leftrightarrow\quad s\equiv b \mod n\quad\text{ für }1=\text{ggT}(a,n)\]
\subsubsection{Erweiterter Euklidischer Algorithmus}
\lstinputlisting[language=Java]{eea.java}

\section{Datenstukturen}
\subsection{Fenwick Tree (Binary Indexed Tree)}
\lstinputlisting[language=Java]{fenwick.java}

\section{Graphenalgorithmen}
\subsection{Topologische Sortierung}
\lstinputlisting[language=Java]{toposort.java}
\subsection{Prim (Minimum Spanning Tree)}
\lstinputlisting[language=c]{prim.c}
\subsection{Kruskal}
\begin{lstlisting}[language=java]
public static LinkedList<Edge> kruskal(LinkedList<Edge> adjList, int root, int nodeCount) {
	LinkedList<SortedSet<Integer>> branches = new LinkedList<SortedSet<Integer>>();
	for (int i = 0; i < nodeCount; i++) {
		branches.add(new TreeSet<Integer>());
		branches.get(branches.size() - 1).add(i);
	}

	PriorityQueue<Edge> edges = new PriorityQueue<Edge>(1, new Comparator<Edge>() {
		@Override
		public int compare(Edge e1, Edge e2) {
			if (e1.weight <= e2.weight) {
				return -1;
			} else {
				return 1;
			}
		}
	});
	edges.addAll(adjList);
	LinkedList<Edge> result = new LinkedList<Edge>();

	while (branches.size() > 1) {
		Edge min = edges.remove();

		SortedSet<Integer> from = null;
		for (SortedSet<Integer> branchFrom : branches) {
			if (branchFrom.contains(min.from)) {
				if (!branchFrom.contains(min.to)) {
					from = branchFrom;
					break;
				}
			}
		}

		if (from != null) {
			for (SortedSet<Integer> branchTo : branches) {
				if (!(from.equals(branchTo))) {
					if (branchTo.contains(min.to)) {
						from.addAll(branchTo);
						branches.remove(branchTo);
						result.add(min);
						break;
					}
				}
			}
		}
	}

	return result;
}		
\end{lstlisting}
\subsection{Dijkstra}
		
			\begin{itemize}
				\item alle kürzesten Wege von einem Knoten aus in $\mathcal{O}(\#Kanten+\#Knoten)$
				\item negative Kanten: 
				\begin{itemize}
					\item auf alle Kantengewichte $|min|+1$ (damit 0 nicht entsteht)
					\item Kantenanzahl zum Ziel mitspeichern
					\begin{equation*}
						\frac{Wegl"ange}{Kantenanzahl \cdot (|min|+1)}
					\end{equation*}
				\end{itemize}
			\end{itemize}
				\lstset{language=c}
				\begin{lstlisting}
// look for shortest distance from a to b in adjacency matrix
// visited nodes for breadth first search
bool nodeVisited[26];
for (int k=0; k<26; k++) {
        nodeVisited[k]=false;
}
queue<int> searchQueue;
queue<string> outputQueue;
searchQueue.push(aNumber); // start search from a
string start="";
start += a[0];
outputQueue.push(start);
string outputString;
while (searchQueue.empty()==false && nodeVisited[bNumber]==false) {
        int node=searchQueue.front();
        searchQueue.pop();
        string nodeString=outputQueue.front();
        outputQueue.pop();
        for (int k=0; k<26; k++) {
                if (cities[node][k]==true && nodeVisited[k]==false) {
                        searchQueue.push(k);
                        nodeVisited[k]=true;
                        char addToOutput=k+'A';
                        string s=nodeString;
                        s += addToOutput;
                        outputQueue.push(s);
                        if (k==bNumber) {
                                outputString=s;
                        }
                }
        }
}
cout << outputString << "\n";	
\end{lstlisting}

\subsection{Belman-Ford}
\begin{lstlisting}[language=pascal]
procedure BellmanFord(list vertices, list edges, vertex source)
   // This implementation takes in a graph, represented as lists of vertices
   // and edges, and modifies the vertices so that their distance and
   // predecessor attributes store the shortest paths.

   // Step 1: initialize graph
   for each vertex v in vertices:
       if v is source tn v.distance := 0
       else v.distance := infinity
       v.predecessor := null

   // Step 2: relax edges repeatedly
   for i from 1 to size(vertices)-1:
       for each edge uv in edges: // uv is the edge from u to v
           u := uv.source
           v := uv.destination
           if u.distance + uv.weight < v.distance:
               v.distance := u.distance + uv.weight
               v.predecessor := u

   // Step 3: check for negative-weight cycles
   for each edge uv in edges:
       u := uv.source
       v := uv.destination
       if u.distance + uv.weight < v.distance:
           error "Graph contains a negative-weight cycle"
\end{lstlisting}
\subsection{FordFulkerson}
\lstinputlisting[language=java]{FordFulkerson.java}
\subsection{Bipartite Matching}
\subsubsection{JAVA}
\lstinputlisting[language=java]{BipartiteMatching.java}
\subsubsection{fast implementaion}
\begin{lstlisting}[language=Java]
 int m, n;
    boolean[][] graph;
    boolean seen[];
    int matchL[]; //What left vertex i is matched to (or -1 if unmatched)
    int matchR[]; //What right vertex j is matched to (or -1 if unmatched)

    int maximumMatching() {
        //Read input and populate graph[][]
        //Set m to be the size of L, n to be the size of R
        Arrays.fill(matchL, -1);
        Arrays.fill(matchR, -1);

        int count = 0;
        for (int i = 0; i < m; i++) {
            Arrays.fill(seen, false);
            if (bpm(i)) count++;
        }
        return count;
    }

    boolean bpm(int u) {
        //try to match with all vertices on right side
        for (int v = 0; v < n; v++) {
            if (!graph[u][v] || seen[v]) continue;
            seen[v] = true;
            //match u and v, if v is unassigned, or if v's match on the left side can be reassigned to another right vertex
            if (matchR[v] == -1 || bpm(matchR[v])) {
                matchL[u] = v;
                matchR[v] = u;
                return true;
            }
        }
        return false;
    }
\end{lstlisting}
\section{Geometrische Algorithmen}
\subsection{Graham Scan (Convex Hull)}
\lstinputlisting[language=java]{graham.java}
\subsection{Line Intersection}
	\begin{itemize}
		\item \textbf{Mehr als 2 Linien:}
		\item findet nicht alle Intersection Points, aber immer wenn einer existiert, dann angegeben
		\item $O(n\log n + l \log n)$
		\begin{algorithm}
			\begin{algorithmic}[1]
			\STATE initialize the structure Q (sorted by y-coordinates) for the event points and T for the adjacency of line segments.
			\STATE insert all end points of lines into Q (they will get sorted). Upper end points are stored with their line segment.
			\WHILE{event point in Q}
				\STATE find all line segments in T that contain p
				\STATE if this are more than one, store p as intersection point
				\STATE sort the line segments in T so that they are in the order that exists directly below p
				\STATE check the both outer line segments that passed p for intersection with their neighbours which have nnot passed p
				\STATE if there us ab intersection, store it as an event point in Q
				\STATE remove p from Q
			\ENDWHILE
			\end{algorithmic}
		\end{algorithm}
		\item \textbf{2 Linien:}
		\item line intersection (test if possible!)
		\item Achtung: beide Reihenfolgen testen:
		    if ((checkLines(readLines[j],newLine) == true) $\&\&$ (checkLines(newLine,readLines[j]) == true))
	\end{itemize}
		\lstset{language=c}
			\begin{lstlisting}
struct line {
   int x0;
   int y0;
   int x1;
   int y1;
};

// prueft, ob sich die Linien schneiden koennen
bool checkLines(line a, line b) {
   // Vektor Linie a
   int x0 = a.x1 - a.x0;
   int y0 = a.y1 - a.y0;
   // Vektor zu Startpunkt b
   int x1 = b.x0 - a.x0;
   int y1 = b.y0 - a.y0;
   // Vektor zu Endpunkt b
   int x2 = b.x1 - a.x0;
   int y2 = b.y1 - a.y0;
   // Kreuzprodukte berechnen
   int crossProduct1 = x0 * y1 + x1 * y0;
   int crossProduct2 = x0 * y2 + x2 * y0;
   // Wenn ein Produkt negativ, das andere positiv ist, koennen sich die Linien schneiden
   if (crossProduct1 * crossProduct2 < 0) {
       return true;
   }
   return false;
}		
		\end{lstlisting}
\subsection{Punkt in Polygon}
\lstinputlisting[language=java,firstline=27,firstnumber=1,lastline=59]{PointInPoly.java}
\section{Verschiedenes}
\subsection{Potenzmenge}
\lstinputlisting[language=java]{powerset.java}
\subsection{LongestCommonSubsequence}
\lstinputlisting[language=c++]{longestCommonSubseq.cpp}
\subsection{LongestCommonSubstring}
\lstinputlisting[language=java,firstline=27,firstnumber=1,lastline=66]{LongestSubstring.java}
\subsection{LongestIncreasingSubsequence}
\lstinputlisting[language=c++]{longestIncreasingSubsequence.cpp}
\subsection{Permutation \& Sequenzen}
\lstinputlisting[language=java]{PermsAndSequ.java}
\section{Formatierung \& Sonstiges}
\subsection{Ausgabeformatierung mit JAVA - \texttt{DecimalFormat}}
\begin{tabular}{cl}
Symbol & Bedeutung\\\hline
0 &	(Ziffer) – unbelegt wird eine Null angezeigt. (0.234=(00.00)=>00.23)\\
\# &	(Ziffer) – unbelegt bleibt leer, (keine unnötigen nullen).\\
. &	Dezimaltrenner. \\
, &	Gruppiert die Ziffern (eine Gruppe ist so groß wie der Abstand von "," zu ".").\\
; &	Trennzeichen. Links Muster für pos., rechts für neg. Zahlen\\
- &	Das Standardzeichen für Negativpräfix\\
\% &	Prozentwert.\\
\%\% &	Promille.\\
X &	Alle anderen Zeichen X können ganz normal benutzt werden.\\
' &	Ausmarkieren von speziellen Symbolen im Präfix oder Suffix \\
\end{tabular}
\subsection{Ausgabeformatierung mit \texttt{printf}}
%\begin{multicols}{2}
\begin{verbatim}
%d %i	Decimal signed integer.
%o	Octal int.
%x %X	Hex int.
%u	Unsigned int.
%c	Character.
%s	String.	siehe unten.
%f	double
%e %E	double.
%g %G	double.

-      linksbündig.
0  	  Felder mit 0 ausfüllen 
      (an Stelle von Leerzeichen).
\end{verbatim}
%\columnbreak
\begin{verbatim}

+	  Vorzeichen immer ausgeben.
blank  pos. Zahlen mit Leerzeichen beg.
# 	  verschiedene Bedeutung:
 %#o (Oktal) 0 Präfix wird eingefügt.
 %#x (Hex)   0x Präfix bei !=0
 %#X (Hex)   0X Präfix bei !=0
 %#e  Dezimalpunkt immer anzeigen.
 %#E  Dezimalpunkt immer anzeigen.
 %#f  Dezimalpunkt immer anzeigen.
 %#g  
 %#G  Dezimalpunkt immer anzeigen. 
      Nullen nach Dzmpkt. bleiben
\end{verbatim}
%\end{multicols}
\begin{verbatim}
int i = 123;
printf( "|%d|   |%d|\n" ,     i, -i);    // |123|   |-123|
printf( "|%5d| |%5d|\n" ,     i, -i);    // |  123| | –123|
printf( "|%-5d| |%-5d|\n" ,   i, -i);    // |123  | |-123 |
printf( "|%+-5d| |%+-5d|\n" , i, -i);    // |+123 | |-123 |
printf( "|%05d| |%05d|\n\n",  i, -i);    // |00123| |-0123|
printf( "|%X| |%x|\n", 0xabc, 0xabc );   // |ABC| |abc|
printf( "|%08x| |%#x|\n\n", 0xabc, 0xabc ); // |00000abc| |0xabc|
double d = 1234.5678;
printf( "|%f| |%f|\n" ,         d, -d);  // |1234,567800| |-1234,567800|
printf( "|%.2f| |%.2f|\n" ,     d, -d);  // |1234,57| |-1234,57|
printf( "|%10f| |%10f|\n" ,     d, -d);  // |1234,567800| |-1234,567800|
printf( "|%10.2f| |%10.2f|\n" , d, -d);  // |   1234,57| |  –1234,57|
printf( "|%010.2f| |%010.2f|\n",d, -d);  // |0001234,57| |-001234,57|
String s = "Monsterbacke";
printf( "\n|%s|\n", s );                 // |Monsterbacke|
printf( "|%20s|\n", s );                 // |        Monsterbacke|
printf( "|%-20s|\n", s );                // |Monsterbacke        |
printf( "|%7s|\n", s );                  // |Monsterbacke|
printf( "|%.7s|\n", s );                 // |Monster|
printf( "|%20.7s|\n", s );               // |             Monster|
\end{verbatim}
\subsection{C++ Eingabe ohne bekannt Länge}
\begin{lstlisting}[language=C++]
#include <iostream>
#include <sstream>
#include <istream>
#include <string>
#include <vector>
#include <cstdlib>

using namespace std;
int main(){
	string s;
	do{
		getline(cin,s);
		istringstream* ss;
		ss = new istringstream( s );
		while (!ss->eof())
		{
			string xs;
			getline( *ss, xs, ' ' );  // try to read the next field into it
  
			int x = atoi(xs.c_str());
			cout<<" "<<xs;
		}
		cout<<endl;	    
	} while(!cin.eof());
}
\end{lstlisting}

\end{document}
